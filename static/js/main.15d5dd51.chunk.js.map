{"version":3,"sources":["store/hierarchy/nodes/types.js","store/hierarchy/nodes/children.js","store/hierarchy/nodes/helpers.js","store/hierarchy/nodes/nodes.js","store/hierarchy/nodes/index.js","components/Tasks/Task.js","components/Tasks/TaskList.js","store/hierarchy/binding.js","store/hierarchy/index.js","store/tasks/index.js","store/tasks/actionTypes.js","store/index.js","components/Tasks/TaskListContainer.js","components/Layout/Header.js","components/Layout/Footer.js","store/tasks/actions.js","App.js","serviceWorker.js","index.js"],"names":["CREATE_NODE_PATH","ADD_CHILD","REMOVE_CHILD","ORDER_CHILD","CREATE_NODE","DELETE_NODE","UPDATE_NODE","CLEAR_NODES","MOVE_NODE","MOVE_NODE_UP","MOVE_NODE_DOWN","INDENT_NODE","UNINDENT_NODE","types","state","action","type","payload","id","at","first","before","after","undefined","filter","child","length","slice","beforeIndex","findIndex","afterIndex","getAllDescendantIds","children","reduce","acc","childId","deleteMany","ids","newState","forEach","descendant","getDescIds","depth","nodeDepth","depthAt","newDepth","getParentId","parent","getLeftSiblingIds","parentId","index","indexOf","leftSiblings","_","reverse","getLeftSiblingId","getRightSiblingIds","rightSiblings","getRightSiblingId","getParentIds","currentId","parentIds","push","count","getIndexes","nodes","newNodes","getIndexesRecurse","node","indexes","root","reducerMoveNode","console","log","indexNode","find","n","makeChild","oldParent","updatedChildren","oldDepth","depthDiff","descendants","Object","assign","getPathPayloadAction","path","sibling","newSibling","parentParentId","googleStyle","nodeId","newNode","idArr","isArray","descendantIds","createNode","updateNode","deleteNode","clearNodes","moveNode","indentNode","unindentNode","DraggableHandle","sortableHandle","DragHandle","style","cursor","connect","dispatch","SortableElement","data","completed","ancestors","dragging","left","right","opacity","ListItem","width","marginLeft","display","flexDirection","Checkbox","checked","value","color","onChange","event","target","TextField","fullWidth","margin","onKeyDown","key","shiftKey","preventDefault","text","newId","uniqueId","setTimeout","document","querySelector","focus","DeleteForever","alignSelf","onClick","SortableContainer","props","hide","draggingTask","List","tasks","map","task","reducer","createAction","updateAction","deleteAction","clearAction","options","combined","combineReducers","binding","includes","has","getBinding","size","values","createNodeDataSelector","createSelector","hierarchy","omit","store","createStore","bound","dataPath","indexing","pick","tasksReducer","applyMiddleware","next","nodePayload","getState","bindings","toString","boundActionType","dataPayload","cascadeLength","cascade","cascadeProp","boundNodes","updatedData","updatedNode","dir","getDescendantIds","getAllChildIds","getAllSiblingIds","isFunction","get","cascadeId","cascadePayload","cascadeData","boundNode","deleteId","allIds","dId","concat","thunk","window","orderedNodeDataSelector","nodeDataSelector","nodeData","orderedNodeIds","orderedNodeList","rootIds","allNodes","o","ordered","orderedNodes","createOrderedNodeDataSelector","TaskListContainer","updateBeforeSortStart","setState","onSortEnd","oldIndex","newIndex","draggedTask","droppedTask","Container","overflow","flex","marginTop","this","useDragHandle","lockAxis","onSortMove","distance","React","Component","Header","AppBar","Toolbar","Typography","variant","clearCompleted","toDelete","sortBy","BottomNavigation","backgroundColor","BottomNavigationAction","label","showLabel","icon","App","className","Boolean","location","hostname","match","rootElement","getElementById","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.15d5dd51.chunk.js","sourcesContent":["export const CREATE_NODE_PATH = 'HIERARCHY/NODES/CREATE_NODE_PATH';\n\nexport const ADD_CHILD = 'HIERARCHY/NODES/ADD_CHILD';\nexport const REMOVE_CHILD = 'HIERARCHY/NODES/REMOVE_CHILD';\nexport const ORDER_CHILD = 'HIERARCHY/NODES/ORDER_CHILD';\nexport const CREATE_NODE = 'HIERARCHY/NODES/CREATE';\nexport const DELETE_NODE = 'HIERARCHY/NODES/DELETE';\nexport const UPDATE_NODE = 'HIERARCHY/NODES/UPDATE';\nexport const CLEAR_NODES = 'HIERARCHY/NODES/CLEAR';\nexport const MOVE_NODE = 'HIERARCHY/NODES/MOVE';\n\nexport const MOVE_NODE_UP = 'HIERARCHY/NODES/MOVE_NODE_UP';\nexport const MOVE_NODE_DOWN = 'HIERARCHY/NODES/MOVE_NODE_DOWN';\nexport const INDENT_NODE = 'HIERARCHY/NODES/INDENT_NODE';\nexport const UNINDENT_NODE = 'HIERARCHY/NODES/UNINDENT_NODE';\n\nexport const types = {\n  ADD_CHILD,\n  CLEAR_NODES,\n  CREATE_NODE,\n  CREATE_NODE_PATH,\n  DELETE_NODE,\n  INDENT_NODE,\n  MOVE_NODE,\n  MOVE_NODE_DOWN,\n  MOVE_NODE_UP,\n  ORDER_CHILD,\n  REMOVE_CHILD,\n  UNINDENT_NODE,\n  UPDATE_NODE,\n};\n","import { ADD_CHILD, REMOVE_CHILD, ORDER_CHILD } from './types';\n\nexport default (state = [], action) => {\n  let { type } = action;\n  const { id, at, first, before, after } = action.payload;\n\n  if (id === undefined) {\n    return state;\n  }\n\n  if (type === ORDER_CHILD) {\n    type = ADD_CHILD;\n    state = state.filter(child => child !== id);\n  }\n\n  switch (type) {\n    case ADD_CHILD: {\n      if (first === true) {\n        return [id, ...state];\n      }\n\n      if (at !== undefined) {\n        if (at <= 0) {\n          return [id, ...state];\n        } else if (at >= state.length) {\n          return [...state, id];\n        }\n\n        return [...state.slice(0, at), id, ...state.slice(at)];\n      }\n\n      if (before !== undefined) {\n        if (state[0] === before) {\n          return [id, ...state];\n        }\n        const beforeIndex = state.findIndex(child => child === before);\n\n        return [\n          ...state.slice(0, beforeIndex),\n          id,\n          ...state.slice(beforeIndex)\n        ];\n      }\n\n      if (after !== undefined) {\n        if (state[state.length - 1] === after) {\n          return [...state, id];\n        }\n\n        const afterIndex = state.findIndex(child => child === after) + 1;\n\n        return [...state.slice(0, afterIndex), id, ...state.slice(afterIndex)];\n      }\n\n      return [...state, id];\n    }\n\n    case REMOVE_CHILD:\n      return state.filter(child => child !== id);\n    default:\n      return state;\n  }\n};\n","import _ from 'lodash';\nimport children from './children';\nimport { REMOVE_CHILD, ORDER_CHILD } from './types';\n\nexport const orderedNodeList = (rootIds, allNodes, o) => {\n  let ordered = o || [];\n\n  _.forEach(rootIds, id => {\n    ordered.push(id);\n    if (allNodes[id].children.length) {\n      ordered = orderedNodeList(allNodes[id].children, allNodes, ordered);\n    }\n  });\n\n  return ordered;\n};\n\nexport const getPath = (node, path = []) => {\n  if (node.parent) {\n    path.push(node.parent.id);\n    path = getPath(node.parent, path);\n  }\n\n  return path;\n};\n\nexport const getAllDescendantIds = (state, id) =>\n  state[id].children.reduce(\n    (acc, childId) => [...acc, childId, ...getAllDescendantIds(state, childId)],\n    []\n  );\n\nexport const deleteMany = (state, ids) => {\n  const newState = { ...state };\n\n  ids.forEach(descendant => {\n    delete newState[descendant];\n  });\n  return newState;\n};\n\nconst getDescIds = (state, id, depth, nodeDepth, depthAt = 0) => {\n  const newDepth = state[id].depth;\n  if (newDepth !== nodeDepth) {\n    depthAt += 1;\n  }\n\n  if (depthAt >= depth) {\n    return state[id].children;\n  }\n\n  return state[id].children.reduce(\n    (acc, childId) => [\n      ...acc,\n      childId,\n      ...getDescIds(state, childId, depth, newDepth, depthAt)\n    ],\n    []\n  );\n};\n\nexport const getDescendantIds = (state, id, depth = -1, depthAt = 0) => {\n  if (depth <= 0) {\n    return getAllDescendantIds(state, id);\n  }\n\n  depth -= 1;\n  const nodeDepth = state[id].depth;\n\n  return getDescIds(state, id, depth, nodeDepth, depthAt);\n};\n\nexport const getAllChildIds = (state, id) => state[id].children;\n\nexport const getParentId = (state, id) => state[id].parent;\n\nexport const getAllSiblingIds = (state, id) => {\n  const parentId = getParentId(state, id);\n  return state[parentId].children;\n};\n\nexport const getLeftSiblingIds = (state, id, length = -1) => {\n  const parentId = getParentId(state, id);\n  const index = state[parentId].children.indexOf(id);\n  let leftSiblings = state[parentId].children.slice(0, index);\n\n  if (length === -1) {\n    return leftSiblings;\n  }\n\n  if (length > leftSiblings.length) {\n    length = leftSiblings.length;\n  }\n\n  leftSiblings = _.reverse(leftSiblings);\n\n  leftSiblings.length = length;\n\n  return _.reverse(leftSiblings);\n};\n\nexport const getLeftSiblingId = (state, id) => {\n  const ids = getLeftSiblingIds(state, id, 1);\n  if (ids.length) {\n    return ids[0];\n  }\n\n  return undefined;\n};\n\nexport const getRightSiblingIds = (state, id, length = -1) => {\n  const parentId = getParentId(state, id);\n  const index = state[parentId].children.indexOf(id) + 1;\n  const rightSiblings = state[parentId].children.slice(index);\n\n  if (length === -1) {\n    return rightSiblings;\n  }\n\n  if (length > rightSiblings.length) {\n    length = rightSiblings.length;\n  }\n\n  rightSiblings.length = length;\n\n  return rightSiblings;\n};\n\nexport const getRightSiblingId = (state, id) => {\n  const ids = getRightSiblingIds(state, id, 1);\n  if (ids.length) {\n    return ids[0];\n  }\n\n  return undefined;\n};\n\nexport const getParentIds = (state, id, depth = -1) => {\n  let currentId = getParentId(state, id);\n\n  if (currentId === 'root') {\n    return [];\n  }\n\n  const parentIds = [];\n  let depthAt = 0;\n\n  while (currentId !== 'root') {\n    if (depth >= 0 && depthAt >= depth) {\n      break;\n    }\n    depthAt += 1;\n    parentIds.push(currentId);\n    currentId = getParentId(state, currentId);\n  }\n\n  return parentIds;\n};\n\nlet count = 0;\n\nconst getIndexesRecurse = (node, indexes, state) => {\n  if (node.children.length > 0) {\n    _.forEach(node.children, childId => {\n      if (indexes[childId] === undefined) {\n        indexes[childId] = count;\n        state[childId] = {\n          ...state[childId],\n          index: count\n        };\n\n        count += 1;\n      }\n      if (state[childId].children) {\n        indexes = getIndexesRecurse(state[childId], indexes, state);\n      }\n    });\n  }\n\n  if (indexes[node.id] === undefined) {\n    indexes[node.id] = count;\n\n    state[node.id] = {\n      ...state[node.id],\n      index: count\n    };\n\n    count += 1;\n  }\n\n  return indexes;\n};\n\nexport const getIndexes = nodes => {\n  const newNodes = { ...nodes };\n  count = 0;\n\n  getIndexesRecurse(newNodes.root, {}, newNodes);\n\n  newNodes.root = {\n    ...newNodes.root,\n    index: -1\n  };\n\n  return newNodes;\n};\n\nexport const reducerMoveNode = (state, payload) => {\n  if (payload.afterIndex !== undefined) {\n    console.log(state, payload);\n    const indexNode = _.find(state, n => n.id === payload.afterIndex);\n\n    if (indexNode.children.length && payload.makeChild) {\n      payload.first = true;\n      payload.parent = indexNode.id;\n    } else {\n      payload.after = indexNode.id;\n      payload.parent = indexNode.parent;\n    }\n  }\n\n  const { id, parent } = payload;\n\n  const parentId = parent || state[id].parent;\n  const oldParent = state[id].parent;\n\n  if (oldParent !== parentId) {\n    const updatedChildren = {};\n    const oldDepth = state[id].depth;\n    const newDepth = parentId === 'root' ? 0 : state[parentId].depth + 1;\n    const depthDiff = newDepth - oldDepth;\n\n    if (depthDiff !== 0 && state[id].children.length) {\n      const descendants = getAllDescendantIds(state, id);\n      _.forEach(descendants, childId => {\n        updatedChildren[childId] = Object.assign({}, state[childId], {\n          depth: state[childId].depth + depthDiff\n        });\n      });\n    }\n\n    return {\n      ...state,\n      ...updatedChildren,\n      [id]: {\n        ...state[id],\n        depth: newDepth,\n        parent: parentId\n      },\n      [oldParent]: {\n        ...state[oldParent],\n        children: children(state[oldParent].children, {\n          payload,\n          type: REMOVE_CHILD\n        })\n      },\n      [parentId]: {\n        ...state[parentId],\n        children: children(state[parentId].children, {\n          payload,\n          type: ORDER_CHILD\n        })\n      }\n    };\n  }\n\n  return {\n    ...state,\n    [parentId]: {\n      ...state[parentId],\n      children: children(state[parentId].children, {\n        payload,\n        type: ORDER_CHILD\n      })\n    }\n  };\n};\n\nexport const getPathPayloadAction = type => {\n  const act = (path, payload) => ({\n    path,\n    payload,\n    type\n  });\n\n  return act;\n};\n","import _ from 'lodash';\nimport children from './children';\nimport {\n  getAllDescendantIds,\n  deleteMany,\n  getLeftSiblingId,\n  getRightSiblingId,\n  reducerMoveNode,\n  getRightSiblingIds\n} from './helpers';\n\nimport {\n  ADD_CHILD,\n  CLEAR_NODES,\n  CREATE_NODE,\n  DELETE_NODE,\n  INDENT_NODE,\n  MOVE_NODE,\n  MOVE_NODE_DOWN,\n  MOVE_NODE_UP,\n  REMOVE_CHILD,\n  UNINDENT_NODE,\n  UPDATE_NODE\n} from './types';\n\nexport default (state = {}, action) => {\n  const { type } = action;\n  const { payload } = action;\n\n  if (type === CLEAR_NODES) {\n    return {\n      root: {\n        children: [],\n        depth: -1,\n        id: 'root',\n        parent: undefined\n      }\n    };\n  }\n\n  if (payload === undefined || payload.id === undefined) {\n    return state;\n  }\n\n  const { id, parent } = payload;\n\n  switch (type) {\n    case UPDATE_NODE:\n    case MOVE_NODE: {\n      return reducerMoveNode(state, payload);\n    }\n    case MOVE_NODE_DOWN: {\n      const sibling = getRightSiblingId(state, id);\n      if (sibling && state[sibling].id !== 'root') {\n        return reducerMoveNode(state, {\n          after: sibling,\n          id\n        });\n      }\n      return state;\n    }\n    case MOVE_NODE_UP: {\n      const sibling = getLeftSiblingId(state, id);\n      if (sibling && state[sibling].id !== 'root') {\n        return reducerMoveNode(state, {\n          before: sibling,\n          id\n        });\n      }\n      return state;\n    }\n    case INDENT_NODE: {\n      const sibling = getLeftSiblingId(state, id);\n      if (sibling && state[sibling].id !== 'root') {\n        return reducerMoveNode(state, {\n          id,\n          parent: sibling\n        });\n      }\n\n      return state;\n    }\n    case UNINDENT_NODE: {\n      const parentId = parent || state[id].parent;\n\n      if (parentId === 'root' || state[parentId] === undefined) {\n        return state;\n      }\n\n      const newSibling = parentId;\n      const parentParentId = state[parentId].parent;\n\n      if (parentParentId) {\n        let newState = reducerMoveNode(state, {\n          after: newSibling,\n          id,\n          parent: parentParentId\n        });\n\n        if (payload.googleStyle) {\n          const rightSiblings = getRightSiblingIds(state, id);\n          _.forEach(rightSiblings, nodeId => {\n            newState = reducerMoveNode(newState, {\n              id: nodeId,\n              parent: id\n            });\n          });\n        }\n        return newState;\n      }\n\n      return state;\n    }\n    case CREATE_NODE: {\n      const parentId = parent || 'root';\n\n      if (state[parentId] === undefined) {\n        return state;\n      }\n\n      const newNode = {\n        children: [],\n        depth: parentId === 'root' ? 0 : state[parentId].depth + 1,\n        id,\n        parent: parentId\n      };\n\n      return {\n        ...state,\n        [id]: newNode,\n        [parentId]: {\n          ...state[parentId],\n          children: children(state[parentId].children, {\n            payload,\n            type: ADD_CHILD\n          })\n        }\n      };\n    }\n    case DELETE_NODE: {\n      let idArr = id;\n      if (!_.isArray(id)) {\n        idArr = [id];\n      }\n\n      let newState = { ...state };\n\n      _.forEach(idArr, childId => {\n        const parentId = state[childId].parent;\n        const descendantIds = getAllDescendantIds(newState, childId);\n\n        newState = {\n          ...deleteMany(newState, [childId, ...descendantIds]),\n          [parentId]: {\n            ...newState[parentId],\n            children: children(newState[parentId].children, {\n              payload: {\n                id: childId\n              },\n              type: REMOVE_CHILD\n            })\n          }\n        };\n      });\n\n      return newState;\n    }\n    default: {\n      return state;\n    }\n  }\n};\n","import _ from 'lodash';\nimport nodes from './nodes';\nimport {\n  CREATE_NODE_PATH,\n  CLEAR_NODES,\n  CREATE_NODE,\n  DELETE_NODE,\n  UPDATE_NODE,\n  MOVE_NODE,\n  INDENT_NODE,\n  MOVE_NODE_UP,\n  UNINDENT_NODE,\n  MOVE_NODE_DOWN\n} from './types';\nimport { getPathPayloadAction } from './helpers';\n\nexport default (state = {}, action) => {\n  const { path, type } = action;\n\n  if (\n    state &&\n    path &&\n    [\n      CREATE_NODE_PATH,\n      CLEAR_NODES,\n      CREATE_NODE,\n      DELETE_NODE,\n      UPDATE_NODE,\n      MOVE_NODE,\n      INDENT_NODE,\n      MOVE_NODE_UP,\n      UNINDENT_NODE,\n      MOVE_NODE_DOWN\n    ].includes(type)\n  ) {\n    if (type === CREATE_NODE_PATH) {\n      return {\n        ...state,\n        [path]: {\n          root: {\n            children: [],\n            depth: -1,\n            id: 'root',\n            parent: undefined\n          }\n        }\n      };\n    }\n\n    if (type === UPDATE_NODE) {\n      const { payload } = action;\n      if (\n        payload &&\n        (_.has(payload, 'parent') ||\n          _.has(payload, 'at') ||\n          _.has(payload, 'first') ||\n          _.has(payload, 'before') ||\n          _.has(payload, 'after') ||\n          _.has(payload, 'afterIndex') ||\n          _.has(payload, 'beforeIndex'))\n      ) {\n        return { ...state, [path]: nodes(state[path], action) };\n      }\n      return state;\n    }\n\n    return { ...state, [path]: nodes(state[path], action) };\n  }\n\n  return state;\n};\n\nexport const createNodePath = path => ({\n  path,\n  type: CREATE_NODE_PATH\n});\n\nexport const createNode = getPathPayloadAction(CREATE_NODE);\n\nexport const updateNode = getPathPayloadAction(UPDATE_NODE);\n\nexport const deleteNode = getPathPayloadAction(DELETE_NODE);\n\nexport const clearNodes = getPathPayloadAction(CLEAR_NODES);\n\nexport const moveNode = getPathPayloadAction(MOVE_NODE);\n\nexport const moveNodeUp = getPathPayloadAction(MOVE_NODE_UP);\n\nexport const moveNodeDown = getPathPayloadAction(MOVE_NODE_DOWN);\n\nexport const indentNode = getPathPayloadAction(INDENT_NODE);\n\nexport const unindentNode = getPathPayloadAction(UNINDENT_NODE);\n","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { SortableElement, sortableHandle } from 'react-sortable-hoc';\r\nimport { uniqueId } from 'lodash';\r\nimport { ListItem } from '@material-ui/core';\r\nimport { DragHandle, DeleteForever } from '@material-ui/icons';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport Checkbox from '@material-ui/core/Checkbox';\r\nimport {\r\n  indentNode,\r\n  unindentNode,\r\n  updateNode,\r\n  deleteNode,\r\n  createNode\r\n} from '../../store/hierarchy/nodes';\r\n\r\nconst DraggableHandle = sortableHandle(() => (\r\n  <DragHandle style={{ cursor: 'grab' }} />\r\n));\r\n\r\nconst Task = ({\r\n  id,\r\n  parent,\r\n  data,\r\n  completed,\r\n  descendants,\r\n  ancestors,\r\n  depth,\r\n  createNode,\r\n  deleteNode,\r\n  indentNode,\r\n  unindentNode,\r\n  updateNode,\r\n  dragging,\r\n  left,\r\n  right\r\n}) => {\r\n  const onKeyDownHandler = event => {\r\n    if (event.key === 'Tab' || (event.key === 'Tab' && event.shiftKey)) {\r\n      event.preventDefault();\r\n    }\r\n\r\n    if (event.key === 'Tab' && event.shiftKey) {\r\n      unindentNode({\r\n        id\r\n      });\r\n    } else if (event.key === 'Tab' && !event.shiftKey) {\r\n      indentNode({\r\n        id\r\n      });\r\n    }\r\n\r\n    if (event.key === 'Backspace' && data.text.length === 0) {\r\n      deleteNode({\r\n        id\r\n      });\r\n    }\r\n\r\n    if (event.key === 'Enter') {\r\n      const newId = uniqueId();\r\n      createNode({\r\n        id: newId,\r\n        parent: parent.id,\r\n        data: {\r\n          text: ''\r\n        }\r\n      });\r\n\r\n      setTimeout(() => {\r\n        document.querySelector(`#text-${newId}`).focus();\r\n      }, 50);\r\n    }\r\n\r\n    if (event.key === 'ArrowDown' && right) {\r\n      document.querySelector(`#text-${right.id}`).focus();\r\n    }\r\n\r\n    if (event.key === 'ArrowUp' && left) {\r\n      document.querySelector(`#text-${left.id}`).focus();\r\n    }\r\n  };\r\n\r\n  const textOnChange = event => {\r\n    updateNode({\r\n      id,\r\n      data: {\r\n        ...data,\r\n        text: event.target.value\r\n      }\r\n    });\r\n  };\r\n\r\n  const checkOnChange = event => {\r\n    const toUpdate = [...descendants, id];\r\n    toUpdate.forEach(id => {\r\n      updateNode({\r\n        id,\r\n        completed: event.target.checked\r\n      });\r\n    });\r\n\r\n    if (parent.id !== 'root') {\r\n      ancestors.forEach(id => {\r\n        updateNode({\r\n          id,\r\n          completed: false\r\n        });\r\n      });\r\n    }\r\n  };\r\n\r\n  const opacity = dragging ? 0.7 : 1;\r\n\r\n  return (\r\n    <ListItem>\r\n      <DraggableHandle />\r\n      <span\r\n        style={{\r\n          width: '100%',\r\n          marginLeft: depth * 15,\r\n          opacity,\r\n          display: 'flex',\r\n          flexDirection: 'row'\r\n        }}\r\n      >\r\n        <Checkbox\r\n          checked={completed}\r\n          value={completed}\r\n          color='primary'\r\n          onChange={checkOnChange}\r\n        />\r\n        <TextField\r\n          id={`text-${id}`}\r\n          fullWidth\r\n          margin='normal'\r\n          onKeyDown={onKeyDownHandler}\r\n          onChange={textOnChange}\r\n          value={data.text}\r\n        />\r\n        <DeleteForever\r\n          color='primary'\r\n          style={{ alignSelf: 'center', cursor: 'pointer' }}\r\n          onClick={() => deleteNode({ id })}\r\n        />\r\n      </span>\r\n    </ListItem>\r\n  );\r\n};\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n  return {\r\n    indentNode: payload => dispatch(indentNode('tasks', payload)),\r\n    unindentNode: payload => dispatch(unindentNode('tasks', payload)),\r\n    updateNode: payload => dispatch(updateNode('tasks', payload)),\r\n    deleteNode: payload => dispatch(deleteNode('tasks', payload)),\r\n    createNode: payload => dispatch(createNode('tasks', payload))\r\n  };\r\n};\r\n\r\nexport default connect(\r\n  null,\r\n  mapDispatchToProps\r\n)(SortableElement(Task));\r\n","import React from 'react';\r\nimport { List } from '@material-ui/core';\r\nimport Task from './Task';\r\nimport { SortableContainer } from 'react-sortable-hoc';\r\n\r\nconst TaskList = props => {\r\n  const hide = props.draggingTask ? props.draggingTask.descendants : [];\r\n\r\n  return (\r\n    <List>\r\n      {props.tasks.map((task, index) => {\r\n        if (hide.find(id => id === task.id)) {\r\n          return null;\r\n        }\r\n        return (\r\n          <Task\r\n            {...task}\r\n            key={task.id}\r\n            dragging={\r\n              props.draggingTask ? props.draggingTask.id === task.id : false\r\n            }\r\n          />\r\n        );\r\n      })}\r\n    </List>\r\n  );\r\n};\r\n\r\nexport default SortableContainer(TaskList);\r\n","const BINDING_SET = 'HIERARCHY/BINDING/SET';\n\nconst reducer = (state = {}, action) => {\n  const { type, payload } = action;\n  switch (type) {\n    case BINDING_SET: {\n      const { path, createAction, updateAction, deleteAction, clearAction } = payload;\n      const options = payload.options || {};\n\n      return {\n        ...state,\n        [path]: {\n          ...options,\n          clearAction,\n          createAction,\n          deleteAction,\n          updateAction,\n        },\n      };\n    }\n    default: {\n      return state;\n    }\n  }\n};\n\nexport const setBinding = payload => ({\n  payload,\n  type: BINDING_SET,\n});\n\nexport default reducer;\n","import _ from 'lodash';\nimport { combineReducers } from 'redux';\nimport { createSelector } from 'reselect';\nimport binding, { setBinding } from './binding';\nimport nodes from './nodes';\nimport {\n  getAllDescendantIds,\n  getDescendantIds,\n  getAllChildIds,\n  getAllSiblingIds,\n  getLeftSiblingId,\n  getLeftSiblingIds,\n  getRightSiblingId,\n  getRightSiblingIds,\n  getParentIds,\n  getParentId,\n  getIndexes,\n  orderedNodeList\n} from './nodes/helpers';\n\nimport {\n  createNode,\n  updateNode,\n  deleteNode,\n  clearNodes,\n  moveNode,\n  moveNodeUp,\n  moveNodeDown,\n  indentNode,\n  unindentNode\n} from './nodes';\n\nimport { types } from './nodes/types';\n\nconst {\n  CREATE_NODE,\n  DELETE_NODE,\n  UPDATE_NODE,\n  CLEAR_NODES,\n  CREATE_NODE_PATH,\n  MOVE_NODE,\n  MOVE_NODE_DOWN,\n  MOVE_NODE_UP,\n  INDENT_NODE,\n  UNINDENT_NODE\n} = types;\n\nconst BINDING_SET = 'HIERARCHY/BINDING/SET';\n\nconst combined = combineReducers({\n  binding,\n  nodes\n});\n\nconst getBinding = (state, action) => {\n  if (state.binding && _.size(state.binding)) {\n    if (Object.values(types).includes(action.type) && action.path) {\n      return state.binding[action.path];\n    }\n  }\n\n  return false;\n};\n\nexport const hierarchy = (state = {}, action) => {\n  const { path, type, payload } = action;\n  const newState = combined(state, action);\n\n  if (action.type === BINDING_SET) {\n    return combined(newState, {\n      path: payload.path,\n      type: CREATE_NODE_PATH\n    });\n  }\n\n  if (type === UNINDENT_NODE) {\n    const bound = getBinding(state, action);\n    if (bound) {\n      payload.googleStyle = bound.googleStyle;\n    }\n  }\n\n  if (newState.binding && _.size(newState.binding) && _.size(newState.nodes)) {\n    _.forEach(newState.binding, (data, dataPath) => {\n      if (data.indexing && dataPath === path) {\n        if (newState.nodes[dataPath] && _.size(newState.nodes[dataPath])) {\n          if (\n            [\n              CREATE_NODE,\n              DELETE_NODE,\n              MOVE_NODE,\n              MOVE_NODE_DOWN,\n              MOVE_NODE_UP,\n              INDENT_NODE,\n              UNINDENT_NODE\n            ].includes(type) ||\n            (type === UPDATE_NODE &&\n              action.payload &&\n              _.pick(action.payload, [\n                'parent',\n                'at',\n                'first',\n                'before',\n                'after'\n              ]).length)\n          ) {\n            newState.nodes[dataPath] = getIndexes(newState.nodes[dataPath]);\n          }\n        }\n      }\n    });\n  }\n\n  return newState;\n};\n\nexport const hierarchyMiddleware = store => next => action => {\n  let nodePayload;\n\n  if (\n    [CREATE_NODE, DELETE_NODE, UPDATE_NODE, CLEAR_NODES].includes(action.type)\n  ) {\n    const state = store.getState();\n    if (state.hierarchy) {\n      const bindings = state.hierarchy.binding;\n\n      const { type, path } = action;\n      let { payload } = action;\n\n      if (bindings && path) {\n        const bound = bindings[path];\n        if (bound) {\n          if (type !== CLEAR_NODES) {\n            if (type === CREATE_NODE && payload === undefined) {\n              payload = {};\n            }\n\n            if (payload.id === undefined) {\n              payload.id = _.uniqueId();\n            } else if (_.isArray(payload.id)) {\n              _.forEach(payload.id, (value, index) => {\n                payload.id[index] = _.toString(value);\n              });\n            } else {\n              payload.id = _.toString(payload.id);\n            }\n          }\n\n          nodePayload = _.pick(payload, [\n            'id',\n            'parent',\n            'at',\n            'first',\n            'before',\n            'after'\n          ]);\n          const dataPayload = _.omit(payload, [\n            'parent',\n            'at',\n            'first',\n            'before',\n            'after',\n            'afterIndex',\n            'cascade',\n            'cascadeProp',\n            'cascadeLength'\n          ]);\n\n          let boundActionType;\n          switch (type) {\n            case CREATE_NODE:\n              boundActionType = bound.createAction;\n              break;\n            case DELETE_NODE:\n              boundActionType = bound.deleteAction;\n              break;\n            case UPDATE_NODE:\n              boundActionType = bound.updateAction;\n              break;\n            case CLEAR_NODES:\n              boundActionType = bound.clearAction;\n              break;\n            default: {\n              boundActionType = undefined;\n            }\n          }\n          if (boundActionType) {\n            if (type === UPDATE_NODE) {\n              const { cascadeLength } = payload;\n              let { cascade, cascadeProp } = payload;\n\n              if (cascade) {\n                const boundNodes = state.hierarchy.nodes[path];\n\n                if (cascadeProp === undefined) {\n                  cascadeProp = _.omit(dataPayload, ['id']);\n                } else if (_.isArray(cascadeProp)) {\n                  cascadeProp = _.omit(_.pick(dataPayload, cascadeProp), [\n                    'id'\n                  ]);\n                }\n\n                let ids = [];\n\n                if (!_.isArray(cascade)) {\n                  cascade = [cascade];\n                }\n\n                _.forEach(cascade, dir => {\n                  if (\n                    ['left', 'right', 'up', 'down'].includes(dir) &&\n                    cascadeLength\n                  ) {\n                    switch (dir) {\n                      case 'left': {\n                        ids = [\n                          ...ids,\n                          ...getLeftSiblingIds(\n                            boundNodes,\n                            payload.id,\n                            cascadeLength\n                          )\n                        ];\n                        break;\n                      }\n                      case 'right': {\n                        ids = [\n                          ...ids,\n                          ...getRightSiblingIds(\n                            boundNodes,\n                            payload.id,\n                            cascadeLength\n                          )\n                        ];\n                        break;\n                      }\n                      case 'up': {\n                        ids = [\n                          ...ids,\n                          ...getParentIds(boundNodes, payload.id, cascadeLength)\n                        ];\n                        break;\n                      }\n                      case 'down': {\n                        ids = [\n                          ...ids,\n                          ...getDescendantIds(\n                            boundNodes,\n                            payload.id,\n                            cascadeLength\n                          )\n                        ];\n                        break;\n                      }\n                      default: {\n                        ids = [];\n                      }\n                    }\n                  } else if (\n                    [\n                      'root',\n                      'parent',\n                      'children',\n                      'descendants',\n                      'siblings',\n                      'leftSiblings',\n                      'rightSiblings',\n                      'leftSibling',\n                      'rightSibling'\n                    ].includes(dir)\n                  ) {\n                    switch (dir) {\n                      case 'root': {\n                        ids = [...ids, ...getParentIds(boundNodes, payload.id)];\n                        break;\n                      }\n                      case 'parent': {\n                        ids = [...ids, getParentId(boundNodes, payload.id)];\n                        break;\n                      }\n                      case 'children': {\n                        ids = [\n                          ...ids,\n                          ...getAllChildIds(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'descendants': {\n                        ids = [\n                          ...ids,\n                          ...getAllDescendantIds(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'siblings': {\n                        ids = [\n                          ...ids,\n                          ...getAllSiblingIds(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'leftSiblings': {\n                        ids = [\n                          ...ids,\n                          ...getLeftSiblingIds(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'rightSiblings': {\n                        ids = [\n                          ...ids,\n                          ...getRightSiblingIds(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'leftSibling': {\n                        ids = [\n                          ...ids,\n                          getLeftSiblingId(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'rightSibling': {\n                        ids = [\n                          ...ids,\n                          getRightSiblingId(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      default: {\n                        ids = [];\n                      }\n                    }\n                  }\n                });\n\n                if (ids.length) {\n                  let updatedData;\n                  let updatedNode;\n\n                  if (_.isFunction(cascadeProp)) {\n                    updatedNode = { ...boundNodes[payload.id] };\n                    updatedData = { ..._.get(state, `${path}.${payload.id}`) };\n                  }\n\n                  _.forEach(ids, cascadeId => {\n                    let cascadePayload = cascadeProp;\n\n                    if (_.isFunction(cascadeProp)) {\n                      const cascadeData = {\n                        ..._.get(state, `${path}.${cascadeId}`)\n                      };\n                      const boundNode = { ...boundNodes[cascadeId] };\n                      cascadePayload = cascadeProp(\n                        payload,\n                        updatedData,\n                        updatedNode,\n                        cascadeData,\n                        boundNode\n                      );\n                    }\n\n                    if (cascadePayload !== null) {\n                      cascadePayload.id = cascadeId;\n\n                      store.dispatch({\n                        payload: cascadePayload,\n                        type: boundActionType\n                      });\n                    }\n                  });\n                }\n              }\n\n              store.dispatch({ payload: dataPayload, type: boundActionType });\n            } else if (type === DELETE_NODE) {\n              let deleteId = dataPayload.id;\n\n              if (!_.isArray(deleteId)) {\n                deleteId = [deleteId];\n              }\n\n              let allIds = [];\n\n              _.forEach(deleteId, dId => {\n                allIds = allIds.concat([\n                  dId,\n                  ...getAllDescendantIds(state.hierarchy.nodes[path], dId)\n                ]);\n              });\n\n              dataPayload.id = allIds;\n\n              store.dispatch({ payload: dataPayload, type: boundActionType });\n            } else {\n              store.dispatch({ payload: dataPayload, type: boundActionType });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (\n    [CREATE_NODE, DELETE_NODE, UPDATE_NODE, CLEAR_NODES].includes(\n      action.type\n    ) &&\n    nodePayload\n  ) {\n    action.payload = nodePayload;\n  }\n\n  return next(action);\n};\n\nexport const bindNodes = (\n  store,\n  path,\n  createAction,\n  updateAction,\n  deleteAction,\n  clearAction,\n  options\n) => {\n  store.dispatch(\n    setBinding({\n      clearAction,\n      createAction,\n      deleteAction,\n      options,\n      path,\n      updateAction\n    })\n  );\n};\n\nexport const createNodeDataSelector = path => {\n  return createSelector(\n    state => _.at(state, path)[0],\n    state => _.at(state.hierarchy.nodes, path)[0],\n    (data, nodes) => {\n      const combined = {};\n\n      _.forEach(nodes, node => {\n        combined[node.id] = {\n          ...node,\n          ...data[node.id]\n        };\n      });\n\n      return combined;\n    }\n  );\n};\n\nexport const createOrderedNodeDataSelector = path => {\n  const nodeDataSelector = createNodeDataSelector(path);\n  return createSelector(\n    nodeDataSelector,\n    nodeData => {\n      const orderedNodeIds = orderedNodeList(nodeData.root.children, nodeData);\n\n      const orderedNodes = [];\n\n      _.forEach(orderedNodeIds, (id, index) => {\n        const node = nodeData[id];\n\n        orderedNodes.push({\n          ...node,\n          index,\n          parent: nodeData[node.parent],\n          descendants: getAllDescendantIds(nodeData, node.id),\n          ancestors: getParentIds(nodeData, node.id),\n          left: nodeData[orderedNodeIds[index - 1]],\n          right: nodeData[orderedNodeIds[index + 1]]\n        });\n      });\n\n      return orderedNodes;\n    }\n  );\n};\n\nexport {\n  getAllDescendantIds,\n  getDescendantIds,\n  getAllChildIds,\n  getAllSiblingIds,\n  getLeftSiblingId,\n  getLeftSiblingIds,\n  getRightSiblingId,\n  getRightSiblingIds,\n  getParentIds,\n  getParentId,\n  createNode,\n  updateNode,\n  deleteNode,\n  clearNodes,\n  moveNode,\n  moveNodeUp,\n  moveNodeDown,\n  indentNode,\n  unindentNode\n};\n","import _ from 'lodash';\r\nimport { ADD_TASK, REMOVE_TASK, UPDATE_TASK, CLEAR_TASKS } from './actionTypes';\r\n\r\nconst reducer = (state = {}, action) => {\r\n  switch (action.type) {\r\n    case ADD_TASK: {\r\n      const id = action.payload.id || _.uniqueId();\r\n\r\n      return {\r\n        ...state,\r\n        [id]: {\r\n          completed: false,\r\n          ...action.payload\r\n        }\r\n      };\r\n    }\r\n\r\n    case REMOVE_TASK: {\r\n      return _.omit(state, [action.payload.id]);\r\n    }\r\n\r\n    case UPDATE_TASK: {\r\n      const id = action.payload.id;\r\n\r\n      const newState = {\r\n        ...state,\r\n        [id]: {\r\n          ...state[id],\r\n          ...action.payload\r\n        }\r\n      };\r\n      return newState;\r\n    }\r\n\r\n    case CLEAR_TASKS: {\r\n      return {};\r\n    }\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nexport default reducer;\r\n","export const ADD_TASK = 'APP/TASKS/ADD';\r\nexport const REMOVE_TASK = 'APP/TASKS/REMOVE';\r\nexport const UPDATE_TASK = 'APP/TASKS/UPDATE';\r\nexport const CLEAR_TASKS = 'APP/TASKS/CLEAR';\r\n","import { combineReducers, createStore, applyMiddleware } from 'redux';\r\nimport {\r\n  hierarchy,\r\n  hierarchyMiddleware,\r\n  bindNodes,\r\n  createNodeDataSelector,\r\n  createOrderedNodeDataSelector\r\n} from './hierarchy';\r\nimport tasksReducer from './tasks';\r\nimport {\r\n  ADD_TASK,\r\n  REMOVE_TASK,\r\n  UPDATE_TASK,\r\n  CLEAR_TASKS\r\n} from './tasks/actionTypes';\r\n\r\nimport thunk from 'redux-thunk';\r\n\r\nconst store = createStore(\r\n  combineReducers({ hierarchy, tasks: tasksReducer }),\r\n  applyMiddleware(hierarchyMiddleware, thunk)\r\n);\r\n\r\nbindNodes(store, 'tasks', ADD_TASK, UPDATE_TASK, REMOVE_TASK, CLEAR_TASKS);\r\n\r\nwindow.store = store;\r\n\r\nexport const nodeDataSelector = createNodeDataSelector('tasks');\r\nexport const orderedNodeDataSelector = createOrderedNodeDataSelector('tasks');\r\n\r\nexport default store;\r\n","import React from 'react';\r\nimport TaskList from './TaskList';\r\nimport { connect } from 'react-redux';\r\nimport { moveNode } from '../../store/hierarchy/nodes';\r\nimport { orderedNodeDataSelector } from '../../store';\r\nimport Container from '@material-ui/core/Container';\r\n\r\nclass TaskListContainer extends React.Component {\r\n  state = {\r\n    draggingTask: null\r\n  };\r\n\r\n  updateBeforeSortStart = ({ index }) => {\r\n    this.setState({\r\n      draggingTask: this.props.tasks[index]\r\n    });\r\n  };\r\n\r\n  onSortEnd = ({ oldIndex, newIndex }) => {\r\n    this.setState({\r\n      draggingTask: null\r\n    });\r\n\r\n    if (oldIndex === newIndex) {\r\n      return;\r\n    }\r\n\r\n    const draggedTask = this.props.tasks[oldIndex];\r\n    const droppedTask = this.props.tasks[newIndex];\r\n\r\n    const dir = newIndex > oldIndex ? 'down' : 'up';\r\n\r\n    const payload = {\r\n      id: draggedTask.id,\r\n      parent:\r\n        droppedTask.descendants.length && dir === 'down'\r\n          ? droppedTask.id\r\n          : droppedTask.parent.id\r\n    };\r\n\r\n    if (dir === 'down') {\r\n      payload.after = droppedTask.id;\r\n    } else {\r\n      payload.before = droppedTask.id;\r\n    }\r\n\r\n    this.props.moveNode(payload);\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <Container\r\n        style={{\r\n          overflow: 'auto',\r\n          flex: 1,\r\n          marginTop: 65\r\n        }}\r\n      >\r\n        <TaskList\r\n          draggingTask={this.state.draggingTask}\r\n          useDragHandle\r\n          lockAxis='y'\r\n          tasks={this.props.tasks}\r\n          onSortEnd={this.onSortEnd}\r\n          onSortMove={this.onSortMove}\r\n          updateBeforeSortStart={this.updateBeforeSortStart}\r\n          distance={5}\r\n        />\r\n      </Container>\r\n    );\r\n  }\r\n}\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n  return {\r\n    moveNode: payload => dispatch(moveNode('tasks', payload))\r\n  };\r\n};\r\n\r\nconst mapDataToProps = state => {\r\n  return {\r\n    tasks: orderedNodeDataSelector(state)\r\n  };\r\n};\r\n\r\nexport default connect(\r\n  mapDataToProps,\r\n  mapDispatchToProps\r\n)(TaskListContainer);\r\n","import React from 'react';\r\nimport AppBar from '@material-ui/core/AppBar';\r\nimport Toolbar from '@material-ui/core/ToolBar';\r\nimport Typography from '@material-ui/core/Typography';\r\n\r\nconst Header = () => {\r\n  return (\r\n    <div style={{ flex: '0 0 auto' }}>\r\n      <AppBar>\r\n        <Toolbar>\r\n          <Typography variant='h6'>Task List</Typography>\r\n        </Toolbar>\r\n      </AppBar>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","import React from 'react';\r\nimport { connect } from 'react-redux';\r\nimport BottomNavigation from '@material-ui/core/BottomNavigation';\r\nimport BottomNavigationAction from '@material-ui/core/BottomNavigationAction';\r\nimport AddIcon from '@material-ui/icons/AddCircleRounded';\r\nimport PlaylistAdd from '@material-ui/icons/PlaylistAdd';\r\nimport PlaylistAddCheck from '@material-ui/icons/PlaylistAddCheck';\r\nimport {\r\n  createNode,\r\n  clearNodes,\r\n  removeNode\r\n} from '../../store/hierarchy/nodes';\r\nimport { clearCompleted } from '../../store/tasks/actions';\r\n\r\nconst Footer = ({ createNode, clearNodes, clearCompleted }) => {\r\n  const addClick = () => {\r\n    createNode({\r\n      data: {\r\n        text: ''\r\n      }\r\n    });\r\n  };\r\n\r\n  const newClick = () => {\r\n    clearNodes();\r\n  };\r\n\r\n  const clearClick = () => {\r\n    clearCompleted();\r\n  };\r\n  return (\r\n    <BottomNavigation style={{ backgroundColor: 'lightgray' }}>\r\n      <BottomNavigationAction\r\n        label='Add Task'\r\n        showLabel\r\n        onClick={addClick}\r\n        icon={<AddIcon color='primary' />}\r\n      />\r\n      <BottomNavigationAction\r\n        label='Clear Completed'\r\n        showLabel\r\n        onClick={clearClick}\r\n        icon={<PlaylistAddCheck color='primary' />}\r\n      />\r\n      <BottomNavigationAction\r\n        label='New List'\r\n        showLabel\r\n        onClick={newClick}\r\n        icon={<PlaylistAdd color='primary' />}\r\n      />\r\n    </BottomNavigation>\r\n  );\r\n};\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n  return {\r\n    createNode: payload => dispatch(createNode('tasks', payload)),\r\n    clearNodes: () => dispatch(clearNodes('tasks')),\r\n    clearCompleted: () => dispatch(clearCompleted())\r\n  };\r\n};\r\n\r\nexport default connect(\r\n  null,\r\n  mapDispatchToProps\r\n)(Footer);\r\n","import { deleteNode } from '../hierarchy/nodes';\r\nimport _ from 'lodash';\r\n\r\nexport function clearCompleted() {\r\n  return (dispatch, getState) => {\r\n    const state = getState();\r\n    const toDelete = [];\r\n\r\n    _.forEach(state.tasks, task => {\r\n      if (task.completed) {\r\n        toDelete.push(state.hierarchy.nodes.tasks[task.id]);\r\n      }\r\n    });\r\n\r\n    _.forEach(_.reverse(_.sortBy(toDelete, ['depth'])), node => {\r\n      dispatch(deleteNode('tasks', { id: node.id }));\r\n    });\r\n  };\r\n}\r\n","import React from 'react';\nimport './App.css';\nimport TaskListContainer from './components/Tasks/TaskListContainer';\nimport Header from './components/Layout/Header';\nimport Footer from './components/Layout/Footer';\n\nfunction App() {\n  return (\n    <div className='App'>\n      <Header />\n      <TaskListContainer />\n      <Footer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { Provider } from 'react-redux';\nimport store from './store';\n\nconst rootElement = document.getElementById('root');\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  rootElement\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}